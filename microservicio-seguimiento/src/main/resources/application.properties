# ===================================================================
# CONFIGURACIÓN DE POSTGRESQL (Debe ser IDÉNTICA al otro servicio)
# ===================================================================

# La URL de conexión. Usa el mismo nombre de base de datos (ej. 'mi_base_de_datos')
spring.datasource.url=jdbc:postgresql://localhost:5432/mi_base_de_datos

# El mismo usuario (ej. 'mi_usuario')
spring.datasource.username=mi_usuario

# La misma contraseña (ej. 'mi_contraseña')
spring.datasource.password=tpi123

spring.datasource.driver-class-name=org.postgresql.Driver

# ===================================================================
# CONFIGURACIÓN DE JPA / HIBERNATE
# ===================================================================

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Usamos 'update'. Cuando arranques este servicio, Hibernate
# leerá las nuevas entidades y creará las tablas:
# 'depositos', 'rutas' y 'tarifas'.
spring.jpa.hibernate.ddl-auto=update

# Opcional: Muestra el SQL en la consola
spring.jpa.show-sql=true


# ===================================================================
# CONFIGURACIÓN DE KEYCLOAK (Spring Security)
# ===================================================================
# Esta es la URL donde Spring Boot irá a buscar la configuración
# y las claves públicas para validar los tokens JWT.
# 'tpi-backend' es el nombre de tu Realm.
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8081/realms/tpi-backend
# ===================================================================
# CONFIGURACIÓN DEL SERVICIO (¡IMPORTANTE!)
# ===================================================================
# 
# Asignamos el puerto 8082.
# 8080 (default) -> microservicio-flota
# 8085 -> microservicio-cliente
# 8083 -> microservicio-seguimiento
#
server.port=8083
# ===================================================================
# CONFIGURACIÓN DE KEYCLOAK (Spring Security)
# ===================================================================
# Esta es la URL donde Spring Boot irá a buscar la configuración
# y las claves públicas para validar los tokens JWT.
# 'tpi-backend' es el nombre de tu Realm.
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8081/realms/tpi-backend
# 1. CONFIGURACIÓN DEL PUERTO DEL SERVIDOR WEB (Netty)
# (Tu microservicio-seguimiento ya tiene server.port=8083, si lo añades, asegúrate de no duplicar)
# server.port=8080 
# 2. CONFIGURACIÓN DE SWAGGER/OPENAPI
springdoc.swagger-ui.path=/swagger-ui.html
# 3. CONFIGURACIÓN DE LA API KEY DE GOOGLE MAPS
google.maps.apikey=AIzaSyCVUJTGkUt0iaXKXTOREr80OQZTdUnsxEM